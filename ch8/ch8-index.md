# 8장. 인덱스

## 8.1 디스크 읽기 방식

### HDD vs SDD

CPU나 메모리같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치 -> 병목의 원인

따라서 기계식 하드 디스크를 대체하기 위해 등장한 것이 SSD

### 랜덤 I/O vs 순차 I/O

HDD의 경우 랜덤 I/O가 순차 I/O보다 느리고, SSD의 경우 랜덤 I/O가 순차 I/O보다 빠름

데이터베이스의 대부분의 작업은 랜덤 I/O를 수행하기 때문에 데이터베이스는 SSD를 사용하는 것이 좋음

## 8.2 인덱스란?

### ArrayList vs SortedList

ArrayList는 값을 저장되는 순서대로 저장하고, SortedList는 정렬된 순서대로 저장

ArrayList는 값을 찾을 때 순차적으로 찾아야 하지만, SortedList는 이진 탐색을 통해 빠르게 찾을 수 있음

따라서 읽기 작업의 경우 SortedList가 더 빠르지만, 삽입/삭제 작업의 경우 ArrayList가 더 빠름

결국 데이터베이스에서는 읽기 작업이 더 많기 때문에 인덱스가 사용하는 방식은 SortedList와 유사하다고도 할 수 있음, 하지만 정렬된 상태로 저장하는 것이 아니라 키와 값으로 저장하는 것이 인덱스의 특징임. 인덱스의 구조는 B-Tree로 구성되어 있음

### 인덱스의 구조

인덱스는 키와 해당 키가 저장된 위치를 저장하는 구조

Key - Value 구조로 저장되어 있으며, 컬럼의 값이 Key, 레코드의 주소가 Value

DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 떨어뜨리지만, 데이터의 읽기(SELECT) 성능을 향상시키는 기능

### 인덱스 알고리즘 
* B-Tree: 데이터를 트리 구조로 저장하며, 컬럼의 값을 변형하지 않고 저장
* Hash: 컬럼의 값으로 해시값을 계산하여 인덱싱, 매우 빠른 검색이 가능하지만, 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없음. 주로 메모리 기반의 데이터베이스에서 사용


## 8.3 B-Tree 인덱스

### 구조 및 특성 

최상위에 루트 노드가 존재, 하위에 자식 노드가 존재, 가장 하위에 있는 노드를 리프 노드라고 하고, 중간에 있는 노드를 브랜치 노드라고 함

데이터 파일의 레코드는 정렬되어 있지 않기 때문에 인덱스의 리프 노드는 데이터 레코드의 위치를 가리키는 포인터를 가지고 있음. 

즉, 브랜치 노드는 자식 노드의 포인터를 가지고 있고, 리프 노드는 데이터 레코드의 위치를 가리키는 구조

InnoDB 테이블에서 레코드는 클러스터 되어 저장되므로, 기본적으로 프라이머리 키를 기준으로 인덱스가 생성됨

클러스터링이란 비슷한 데이터를 묶어서 저장하는 것을 의미

### B-Tree 인덱스의 키 추가 및 삭제

키 추가의 경우: 

B-Tree를 추가할 때 적절한 위치를 검색해야 하는데, 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소를 리프 노드에 추가함

리프 노드가 꽉 차면 리프 노드를 분할하고, 브랜치 노드가 꽉 차면 브랜치 노드를 분할하는 탓에 인덱스의 추가/삭제 작업은 느림

키 삭제의 경우:

해당 키 값이 저장된 리프 노드를 찾아서 삭제하고, 삭제 마크를 표시하면 완료

키 변경의 경우:

키를 삭제하고 새로운 키를 추가하는 방식으로 처리

체인지 버퍼를 활용해 지연 처리

키 검색의 경우: 

루트 노드부터 브랜치 노드를 거쳐 리프 노드까지 이동하며 비교 작업을 수행하는데 이를 트리 탐색이라고 함.

B-Tree 인덱스를 이용한 검색은 100%일치하거나 앞부분이 일치하는 경우에만 사용 가능하기 때문에, 인덱스를 사용할 수 없는 경우에는 테이블 풀 스캔을 수행함

InnoDB 테이블에서 지원하는 레코드 잠금 또는 넥스트 키 잠금(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현됨.

### B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스를 구성하는 컬럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 등에 의해 영향을 받음

* 인덱스 키 값의 크기: 인덱스도 결국 페이지로 관리되는데, 각 노드가 한 페이지가 됨. 이진 트리가 아니라 Balanced Tree이기 때문에 자식 노드의 개수가 가변적임. 키값이 커지면 페이징이 많아져, 디스크 I/O가 많아짐.
결국 성능이 떨어짐
* B-Tree 인덱스의 깊이: B-Tree 인덱스의 깊이를 직접 제어할 수는 없음. 인덱스 키 값의 크기가 커지면 깊이도 깊어짐
* 기수성(Cardinality): 인덱스 키 값의 유니크한 값의 개수를 의미. 중복된 값이 많아질수록 기수성이 낮아짐. 기수성이 낮으면 인덱스의 크기가 커지고, 성능이 떨어짐
* 읽어야 하는 레코드 건수: 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블의 20~25%를 넘어서면 인덱스를 사용하는 것이 성능 저하를 초래할 수 있음. 이 경우 테이블 전체를 스캔하는 것이 더 빠를 수 있음. 이것은 옵티마이저가 판단.

### B-Tree 인덱스를 통해 데이터 일긱

1. 인덱스 레인지 스캔
- 인덱스를 통해 데이터를 읽는 방식 중 가장 빠른 방식
- 인덱스를 통해 읽어야 할 레코드의 범위를 지정하면, 해당 범위의 레코드를 읽어오는 방식
- 리프 노드의 레코드만 순서대로 읽어오기 때문에 빠름
